"""
GitHub Claude Webhook Service

A FastAPI-based webhook service that automatically responds to GitHub issues using Claude AI.
This service listens for GitHub webhook events and provides AI-powered responses to issues
marked with the 'claude-discuss' label, and automatically implements solutions for issues
marked with the 'claude-implement' label.

Supported labels:
- claude-discuss: Provides AI-powered discussion and analysis
- claude-implement: Automatically implements solutions and creates pull requests

Reference: https://docs.github.com/en/webhooks/webhook-events-and-payloads
"""

import subprocess
import json
import hmac
import hashlib
import os
import logging
from typing import Any
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
import uvicorn
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

load_dotenv()

app = FastAPI(title="GitHub Claude Webhook")

claude_reply_signature_zh = "\n\n---\n*ðŸ”§ æ­¤å›žè¦†ç”± [Claude Code](https://claude.ai/code) è‡ªå‹•ç”Ÿæˆ*"
claude_reply_signature_en = (
    "\n\n---\n*ðŸ”§ This reply was automatically generated by [Claude Code](https://claude.ai/code)*"
)


def post_comment(repo: str, issue_number: int, comment: str) -> bool:
    try:
        cmd = ["gh", "issue", "comment", str(issue_number), "--repo", repo, "--body", comment]
        subprocess.run(cmd, capture_output=True, text=True, check=True)
        return True
    except subprocess.CalledProcessError as e:
        logger.error(f"Error posting comment: {e.stderr}")
        return False


def get_issue_info(repo_path: Path, issue_number: int) -> dict:
    try:
        gh_cmd = [
            "gh",
            "issue",
            "view",
            str(issue_number),
            "--json",
            "title,body,author,labels,state,comments",
        ]
        gh_result = subprocess.run(
            gh_cmd, cwd=repo_path, capture_output=True, text=True, check=True
        )
        issue_info = json.loads(gh_result.stdout)
        logger.info(f"Viewing issue #{issue_number}: {issue_info.get('title')}...")
        return issue_info
    except subprocess.CalledProcessError as e:
        logger.error(f"Error viewing issue with gh: {e.stderr}")
        raise HTTPException(status_code=500, detail="Failed to fetch issue details")
    except Exception as e:
        logger.error(f"Unexpected error viewing issue: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to fetch issue details")


def extract_repo_and_issue_info(payload: dict[str, Any]) -> tuple[str, int]:
    repo_full_name = payload.get("repository", {}).get("full_name")
    issue_number = payload.get("issue", {}).get("number")
    return repo_full_name, issue_number


def analyze_issue_with_claude(issue_data: str) -> str:
    prompt = f"""ä½œç‚ºä¸€å€‹å°ˆæ¥­çš„è»Ÿé«”é–‹ç™¼åŠ©æ‰‹ï¼Œè«‹åˆ†æžä»¥ä¸‹ GitHub issue ä¸¦æä¾›å»ºè¨­æ€§çš„å›žæ‡‰ã€‚
ä»¥ä¸‹æ˜¯ issue çš„è©³ç´°è³‡è¨Šï¼Œä»¥ JSON æ ¼å¼å‘ˆç¾ï¼š

{issue_data}

è«‹æ ¹æ“šä»¥ä¸Šå°è©±æ­·å²ï¼Œæä¾›é©ç•¶çš„å›žæ‡‰æˆ–ç¹¼çºŒè¨Žè«–ï¼Œå¯åƒè€ƒä»¥ä¸‹å»ºè­°ï¼š
1. å°é€™å€‹ issue çš„åˆ†æžï¼ˆå¦‚æžœæ˜¯é¦–æ¬¡å›žæ‡‰ï¼‰æˆ–å°æœ€æ–°ç•™è¨€çš„å›žæ‡‰
2. å»ºè­°çš„å¾ŒçºŒæ­¥é©Ÿæˆ–è§£æ±ºæ–¹å‘
3. å¦‚æžœéœ€è¦æ›´å¤šè³‡è¨Šï¼Œè«‹å…·é«”èªªæ˜Žéœ€è¦ä»€éº¼
4. é©ç•¶çš„è¡¨æƒ…ç¬¦è™Ÿè®“å›žæ‡‰æ›´å‹å–„

è«‹ç”¨ç¹é«”ä¸­æ–‡å›žæ‡‰ï¼Œä¿æŒå°ˆæ¥­ä½†å‹å–„çš„èªžèª¿ã€‚
è«‹æ³¨æ„ï¼Œå›žæ‡‰å¿…é ˆä»¥ä»¥ä¸‹æ ¼å¼çµå°¾ï¼š

{claude_reply_signature_zh}
"""

    try:
        timeout = int(os.getenv("CLAUDE_TIMEOUT", "300"))
        result = subprocess.run(
            ["claude", prompt],
            capture_output=True,
            text=True,
            check=True,
            timeout=timeout,
        )
        return f"{result.stdout.strip()}"
    except subprocess.CalledProcessError as e:
        logger.error(f"Claude API error: {e.stderr}")
        return f"ðŸ¤– åˆ†æžç³»çµ±æš«æ™‚ç„¡æ³•ä½¿ç”¨ã€‚æˆ‘æœƒç¨å¾ŒæŸ¥çœ‹é€™å€‹ issueã€‚{claude_reply_signature_zh}"
    except subprocess.TimeoutExpired:
        logger.error("Claude API timeout")
        return f"ðŸ¤– åˆ†æžè™•ç†æ™‚é–“éŽé•·ï¼Œæˆ‘æœƒç¨å¾ŒæŸ¥çœ‹é€™å€‹ issueã€‚{claude_reply_signature_zh}"
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return f"ðŸ¤– ç³»çµ±ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤ï¼Œæˆ‘æœƒç¨å¾ŒæŸ¥çœ‹é€™å€‹ issueã€‚{claude_reply_signature_zh}"


def implement_issue_with_claude(
    repo_path: Path, repo_full_name: str, issue_number: int, issue_info: dict
) -> bool:
    logger.info(f"Starting implementation for issue #{issue_number}: {issue_info.get('title')}...")
    try:
        branch_name = f"claude-implement-{issue_number}"

        subprocess.run(
            ["git", "pull", "--rebase"],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )

        subprocess.run(
            ["git", "branch", "-D", branch_name],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )

        subprocess.run(
            ["git", "checkout", "-b", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )

        logger.info(f"Created branch: {branch_name}")

        prompt = f"""è«‹ä½ ä½œç‚ºä¸€å€‹å°ˆæ¥­çš„è»Ÿé«”é–‹ç™¼è€…ï¼Œæ ¹æ“šä»¥ä¸‹ GitHub issue é€²è¡Œå¯¦ä½œã€‚

Issue è³‡è¨Šï¼š

{json.dumps(issue_info, ensure_ascii=False)}

ä»¥å‰µå»ºç«‹æ–°çš„åˆ†æ”¯ï¼Œè«‹æŒ‰ç…§ä»¥ä¸‹æ­¥é©Ÿé€²è¡Œï¼š
1. åˆ†æž issue çš„éœ€æ±‚å’Œç›®æ¨™
2. æŸ¥çœ‹ç¾æœ‰çš„ä»£ç¢¼çµæ§‹å’Œç›¸é—œæ–‡ä»¶
3. å¯¦ä½œæ‰€éœ€çš„åŠŸèƒ½æˆ–ä¿®å¾©
4. ç¢ºä¿ä»£ç¢¼é¢¨æ ¼ä¸€è‡´
5. å¦‚æžœéœ€è¦ï¼Œé€²è¡Œé‡æ§‹èˆ‡å„ªåŒ–
6. å¦‚æžœéœ€è¦ï¼Œæ›´æ–°ç›¸é—œçš„æ¸¬è©¦
7. æäº¤æ›´æ”¹ï¼ŒåŸ·è¡Œ git add å’Œ git commit æŒ‡ä»¤
  - ä½¿ç”¨**è‹±æ–‡**æ’°å¯«
  - éœ€ä½¿ç”¨ conventional commit message æ ¼å¼
  - è¨»æ˜Žç¨‹å¼ç¢¼ç”± Claude Code è‡ªå‹•ç”Ÿæˆ

è«‹ç¢ºä¿ä½ çš„å¯¦ä½œï¼š
- ç¬¦åˆ issue çš„å…·é«”è¦æ±‚
- éµå¾ªç¾æœ‰çš„ä»£ç¢¼é¢¨æ ¼å’Œæ…£ä¾‹
- åŒ…å«é©ç•¶çš„éŒ¯èª¤è™•ç†
- å…·æœ‰è‰¯å¥½çš„å¯è®€æ€§å’Œå¯ç¶­è­·æ€§

å®Œæˆå¯¦ä½œå¾Œï¼Œéœ€è¦å»ºç«‹ Pull Request
- ä¸éœ€åŸ·è¡Œ PR æŒ‡ä»¤ï¼Œåªéœ€æä¾› PR çš„æ¨™é¡Œå’Œèªªæ˜Ž
- è«‹**ç”¨è‹±æ–‡**æè¿°ä½ æ‰€åšçš„æ›´æ”¹
- è¨˜å¾—å¢žåŠ  Closes #{issue_number} åˆ°èªªæ˜Žä¸­
"""

        timeout = int(os.getenv("CLAUDE_TIMEOUT", "300"))
        result = subprocess.run(
            ["claude", prompt, "--permission-mode", "bypassPermissions"],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True,
            timeout=timeout,
        )
        logger.info("Claude implementation completed")

        subprocess.run(
            ["git", "push", "-u", "origin", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )
        logger.info(f"Pushed branch {branch_name} to remote")

        pr_title = f"ðŸ¤– Implement issue #{issue_number}"
        pr_body = result.stdout.strip()

        subprocess.run(
            ["gh", "pr", "create", "-t", pr_title, "-b", pr_body, "-B", "main", "-H", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )
        logger.info(f"Pull request created for issue #{issue_number}")
        
        comment = f"ðŸ¤– æˆ‘å·²ç¶“åˆ†æžäº†é€™å€‹ issue ä¸¦å‰µå»ºäº†å¯¦ä½œæ–¹æ¡ˆï¼\n\nå·²è‡ªå‹•å‰µå»º PR ä¾†è§£æ±ºæ­¤å•é¡Œã€‚è«‹æŸ¥çœ‹ä¸¦å¯©æ ¸ä»£ç¢¼ã€‚\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, comment)
        return True

    except subprocess.CalledProcessError as e:
        logger.error(f"Error during implementation: {e.stderr}")
        error_comment = f"ðŸ¤– å¯¦ä½œéŽç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ï¼š\n\n```\n{e.stderr}\n```\n\nè«‹æª¢æŸ¥ issue å…§å®¹æˆ–è¯ç¹«ç®¡ç†å“¡ã€‚\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, error_comment)
        return False
    except subprocess.TimeoutExpired:
        logger.error("Claude implementation timeout")
        timeout_comment = f"ðŸ¤– å¯¦ä½œè™•ç†æ™‚é–“éŽé•·ï¼Œå·²è¶…æ™‚ã€‚\n\né€™å¯èƒ½æ˜¯å› ç‚ºï¼š\n- Issue éŽæ–¼è¤‡é›œ\n- éœ€è¦æ›´å¤šæ™‚é–“åˆ†æžä»£ç¢¼åº«\n\nè«‹ç¨å¾Œé‡è©¦æˆ–å°‡å•é¡Œåˆ†è§£ç‚ºæ›´å°çš„ä»»å‹™ã€‚\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, timeout_comment)
        return False
    except Exception as e:
        logger.error(f"Unexpected error during implementation: {str(e)}")
        error_comment = f"ðŸ¤– å¯¦ä½œéŽç¨‹ä¸­ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤ã€‚\n\nè«‹ç¨å¾Œé‡è©¦æˆ–è¯ç¹«ç®¡ç†å“¡ã€‚\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, error_comment)
        return False


async def handle_claude_discuss(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    repo_full_name, issue_number = extract_repo_and_issue_info(payload)

    issue_info = get_issue_info(repo_path, issue_number)
    claude_thoughts = analyze_issue_with_claude(json.dumps(issue_info, ensure_ascii=False))
    success = post_comment(repo_full_name, issue_number, claude_thoughts)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to post comment")

    logger.info(f"Comment posted successfully for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Comment posted successfully"}, status_code=200)


async def handle_claude_implement(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    repo_full_name, issue_number = extract_repo_and_issue_info(payload)

    issue_info = get_issue_info(repo_path, issue_number)
    success = implement_issue_with_claude(repo_path, repo_full_name, issue_number, issue_info)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to implement issue")

    logger.info(f"Implementation completed for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Implementation completed and PR created"}, status_code=200)


async def handle_issues_labeled(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    label = payload.get("label", {}).get("name")
    if label == "claude-discuss":
        return await handle_claude_discuss(repo_path, payload)
    elif label == "claude-implement":
        return await handle_claude_implement(repo_path, payload)
    else:
        logger.info(f"Label ignored: {label}")
        return JSONResponse({"message": f"Label ignored: {label}"}, status_code=200)


async def handle_issue_comment_created(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    issue = payload.get("issue", {})
    issue_labels = issue.get("labels", [])
    if not any(label.get("name") == "claude-discuss" for label in issue_labels):
        logger.info(f"Issue #{issue.get('number')} not marked for claude-discuss")
        return JSONResponse({"message": "Issue not marked for claude-discuss"}, status_code=200)

    repo_full_name, _ = extract_repo_and_issue_info(payload)
    issue_number = issue.get("number")

    issue_info = get_issue_info(repo_path, issue_number)
    comments = issue_info.get("comments", [])
    if comments and comments[-1].get("body", "").endswith(claude_reply_signature_zh):
        logger.info(f"Issue #{issue_number} already has a Claude reply, skipping...")
        return JSONResponse({"message": "Claude reply already exists"}, status_code=200)

    claude_thoughts = analyze_issue_with_claude(json.dumps(issue_info, ensure_ascii=False))
    success = post_comment(repo_full_name, issue_number, claude_thoughts)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to post reply")

    logger.info(f"Reply posted successfully for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Reply posted successfully"}, status_code=200)


@app.post("/webhook")
async def github_webhook(request: Request):
    try:
        secret = os.getenv("GITHUB_WEBHOOK_SECRET")
        if not secret:
            raise HTTPException(status_code=500, detail="Webhook secret not configured")

        signature = request.headers.get("X-Hub-Signature-256")
        if not signature:
            raise HTTPException(status_code=400, detail="Missing signature header")

        payload_body = await request.body()
        expected_signature = hmac.new(
            secret.encode("utf-8"), payload_body, hashlib.sha256
        ).hexdigest()
        if not hmac.compare_digest(f"sha256={expected_signature}", signature):
            raise HTTPException(status_code=401, detail="Invalid signature")

        payload = json.loads(payload_body)
        event_type = request.headers.get("X-GitHub-Event") + "." + payload.get("action")

        repository = payload.get("repository", {})
        repo_full_name = repository.get("full_name")
        ssh_url = repository.get("ssh_url")

        workdir = Path.home() / "workdir"
        workdir.mkdir(exist_ok=True)
        repo_path = workdir / repo_full_name.split("/")[-1]

        if not repo_path.exists():
            try:
                subprocess.run(
                    ["git", "clone", ssh_url, "--depth", "1"],
                    cwd=workdir,
                    check=True,
                    capture_output=True,
                    text=True,
                )
                logger.info(f"Cloned repository: {repo_full_name}")
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to clone repository {repo_full_name}: {e.stderr}")
                raise HTTPException(status_code=500, detail="Failed to clone repository")
        else:
            logger.info(f"Repository already exists: {repo_path}")
            subprocess.run(
                ["git", "checkout", "main"],
                cwd=repo_path,
                check=True,
                capture_output=True,
                text=True,
            )

        if event_type == "issues.labeled":
            return await handle_issues_labeled(repo_path, payload)
        elif event_type == "issue_comment.created":
            return await handle_issue_comment_created(repo_path, payload)
        else:
            logger.info(f"Event ignored: {event_type}")
            return JSONResponse({"message": "Event ignored"}, status_code=200)

    except Exception as e:
        logger.error(f"Webhook error: {e}")
        raise HTTPException(status_code=500, detail=e)


@app.get("/")
async def health_check():
    return {"status": "GitHub Issue Webhook is running"}


if __name__ == "__main__":
    port = int(os.getenv("PORT", "8000"))
    uvicorn.run(app, host="0.0.0.0", port=port)
