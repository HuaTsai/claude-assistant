"""
GitHub Claude Webhook Service

A FastAPI-based webhook service that automatically responds to GitHub issues using Claude AI.
This service listens for GitHub webhook events and provides AI-powered responses to issues
marked with the 'claude-discuss' label, and automatically implements solutions for issues
marked with the 'claude-implement' label.

Supported labels:
- claude-discuss: Provides AI-powered discussion and analysis
- claude-implement: Automatically implements solutions and creates pull requests

Reference: https://docs.github.com/en/webhooks/webhook-events-and-payloads
"""

import subprocess
import json
import hmac
import hashlib
import os
import logging
from typing import Any
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from dotenv import load_dotenv
import uvicorn
from pathlib import Path

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)
logger = logging.getLogger(__name__)

load_dotenv()

app = FastAPI(title="GitHub Claude Webhook")

claude_reply_signature_zh = "\n\n---\n*🔧 此回覆由 [Claude Code](https://claude.ai/code) 自動生成*"
claude_reply_signature_en = (
    "\n\n---\n*🔧 This reply was automatically generated by [Claude Code](https://claude.ai/code)*"
)


def post_comment(repo: str, issue_number: int, comment: str) -> bool:
    try:
        cmd = ["gh", "issue", "comment", str(issue_number), "--repo", repo, "--body", comment]
        subprocess.run(cmd, capture_output=True, text=True, check=True)
        return True
    except subprocess.CalledProcessError as e:
        logger.error(f"Error posting comment: {e.stderr}")
        return False


def get_issue_info(repo_path: Path, issue_number: int) -> dict:
    try:
        gh_cmd = [
            "gh",
            "issue",
            "view",
            str(issue_number),
            "--json",
            "title,body,author,labels,state,comments",
        ]
        gh_result = subprocess.run(
            gh_cmd, cwd=repo_path, capture_output=True, text=True, check=True
        )
        issue_info = json.loads(gh_result.stdout)
        logger.info(f"Viewing issue #{issue_number}: {issue_info.get('title')}...")
        return issue_info
    except subprocess.CalledProcessError as e:
        logger.error(f"Error viewing issue with gh: {e.stderr}")
        raise HTTPException(status_code=500, detail="Failed to fetch issue details")
    except Exception as e:
        logger.error(f"Unexpected error viewing issue: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to fetch issue details")


def extract_repo_and_issue_info(payload: dict[str, Any]) -> tuple[str, int]:
    repo_full_name = payload.get("repository", {}).get("full_name")
    issue_number = payload.get("issue", {}).get("number")
    return repo_full_name, issue_number


def analyze_issue_with_claude(issue_data: str) -> str:
    prompt = f"""作為一個專業的軟體開發助手，請分析以下 GitHub issue 並提供建設性的回應。
以下是 issue 的詳細資訊，以 JSON 格式呈現：

{issue_data}

請根據以上對話歷史，提供適當的回應或繼續討論，可參考以下建議：
1. 對這個 issue 的分析（如果是首次回應）或對最新留言的回應
2. 建議的後續步驟或解決方向
3. 如果需要更多資訊，請具體說明需要什麼
4. 適當的表情符號讓回應更友善

請用繁體中文回應，保持專業但友善的語調。
請注意，回應必須以以下格式結尾：

{claude_reply_signature_zh}
"""

    try:
        timeout = int(os.getenv("CLAUDE_TIMEOUT", "300"))
        result = subprocess.run(
            ["claude", prompt],
            capture_output=True,
            text=True,
            check=True,
            timeout=timeout,
        )
        return f"{result.stdout.strip()}"
    except subprocess.CalledProcessError as e:
        logger.error(f"Claude API error: {e.stderr}")
        return f"🤖 分析系統暫時無法使用。我會稍後查看這個 issue。{claude_reply_signature_zh}"
    except subprocess.TimeoutExpired:
        logger.error("Claude API timeout")
        return f"🤖 分析處理時間過長，我會稍後查看這個 issue。{claude_reply_signature_zh}"
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        return f"🤖 系統發生未預期的錯誤，我會稍後查看這個 issue。{claude_reply_signature_zh}"


def implement_issue_with_claude(
    repo_path: Path, repo_full_name: str, issue_number: int, issue_info: dict
) -> bool:
    logger.info(f"Starting implementation for issue #{issue_number}: {issue_info.get('title')}...")
    try:
        branch_name = f"claude-implement-{issue_number}"

        subprocess.run(
            ["git", "pull", "--rebase"],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )

        subprocess.run(
            ["git", "branch", "-D", branch_name],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )

        subprocess.run(
            ["git", "checkout", "-b", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )

        logger.info(f"Created branch: {branch_name}")

        prompt = f"""請你作為一個專業的軟體開發者，根據以下 GitHub issue 進行實作。

Issue 資訊：

{json.dumps(issue_info, ensure_ascii=False)}

以創建立新的分支，請按照以下步驟進行：
1. 分析 issue 的需求和目標
2. 查看現有的代碼結構和相關文件
3. 實作所需的功能或修復
4. 確保代碼風格一致
5. 如果需要，進行重構與優化
6. 如果需要，更新相關的測試
7. 提交更改，執行 git add 和 git commit 指令
  - 使用**英文**撰寫
  - 需使用 conventional commit message 格式
  - 註明程式碼由 Claude Code 自動生成

請確保你的實作：
- 符合 issue 的具體要求
- 遵循現有的代碼風格和慣例
- 包含適當的錯誤處理
- 具有良好的可讀性和可維護性

完成實作後，需要建立 Pull Request
- 不需執行 PR 指令，只需提供 PR 的標題和說明
- 請**用英文**描述你所做的更改
- 記得增加 Closes #{issue_number} 到說明中
"""

        timeout = int(os.getenv("CLAUDE_TIMEOUT", "300"))
        result = subprocess.run(
            ["claude", prompt, "--permission-mode", "bypassPermissions"],
            cwd=repo_path,
            capture_output=True,
            text=True,
            check=True,
            timeout=timeout,
        )
        logger.info("Claude implementation completed")

        subprocess.run(
            ["git", "push", "-u", "origin", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )
        logger.info(f"Pushed branch {branch_name} to remote")

        pr_title = f"🤖 Implement issue #{issue_number}"
        pr_body = result.stdout.strip()

        subprocess.run(
            ["gh", "pr", "create", "-t", pr_title, "-b", pr_body, "-B", "main", "-H", branch_name],
            cwd=repo_path,
            check=True,
            capture_output=True,
            text=True,
        )
        logger.info(f"Pull request created for issue #{issue_number}")
        
        comment = f"🤖 我已經分析了這個 issue 並創建了實作方案！\n\n已自動創建 PR 來解決此問題。請查看並審核代碼。\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, comment)
        return True

    except subprocess.CalledProcessError as e:
        logger.error(f"Error during implementation: {e.stderr}")
        error_comment = f"🤖 實作過程中發生錯誤：\n\n```\n{e.stderr}\n```\n\n請檢查 issue 內容或聯繫管理員。\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, error_comment)
        return False
    except subprocess.TimeoutExpired:
        logger.error("Claude implementation timeout")
        timeout_comment = f"🤖 實作處理時間過長，已超時。\n\n這可能是因為：\n- Issue 過於複雜\n- 需要更多時間分析代碼庫\n\n請稍後重試或將問題分解為更小的任務。\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, timeout_comment)
        return False
    except Exception as e:
        logger.error(f"Unexpected error during implementation: {str(e)}")
        error_comment = f"🤖 實作過程中發生未預期的錯誤。\n\n請稍後重試或聯繫管理員。\n\n{claude_reply_signature_zh}"
        post_comment(repo_full_name, issue_number, error_comment)
        return False


async def handle_claude_discuss(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    repo_full_name, issue_number = extract_repo_and_issue_info(payload)

    issue_info = get_issue_info(repo_path, issue_number)
    claude_thoughts = analyze_issue_with_claude(json.dumps(issue_info, ensure_ascii=False))
    success = post_comment(repo_full_name, issue_number, claude_thoughts)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to post comment")

    logger.info(f"Comment posted successfully for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Comment posted successfully"}, status_code=200)


async def handle_claude_implement(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    repo_full_name, issue_number = extract_repo_and_issue_info(payload)

    issue_info = get_issue_info(repo_path, issue_number)
    success = implement_issue_with_claude(repo_path, repo_full_name, issue_number, issue_info)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to implement issue")

    logger.info(f"Implementation completed for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Implementation completed and PR created"}, status_code=200)


async def handle_issues_labeled(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    label = payload.get("label", {}).get("name")
    if label == "claude-discuss":
        return await handle_claude_discuss(repo_path, payload)
    elif label == "claude-implement":
        return await handle_claude_implement(repo_path, payload)
    else:
        logger.info(f"Label ignored: {label}")
        return JSONResponse({"message": f"Label ignored: {label}"}, status_code=200)


async def handle_issue_comment_created(repo_path: Path, payload: dict[str, Any]) -> JSONResponse:
    issue = payload.get("issue", {})
    issue_labels = issue.get("labels", [])
    if not any(label.get("name") == "claude-discuss" for label in issue_labels):
        logger.info(f"Issue #{issue.get('number')} not marked for claude-discuss")
        return JSONResponse({"message": "Issue not marked for claude-discuss"}, status_code=200)

    repo_full_name, _ = extract_repo_and_issue_info(payload)
    issue_number = issue.get("number")

    issue_info = get_issue_info(repo_path, issue_number)
    comments = issue_info.get("comments", [])
    if comments and comments[-1].get("body", "").endswith(claude_reply_signature_zh):
        logger.info(f"Issue #{issue_number} already has a Claude reply, skipping...")
        return JSONResponse({"message": "Claude reply already exists"}, status_code=200)

    claude_thoughts = analyze_issue_with_claude(json.dumps(issue_info, ensure_ascii=False))
    success = post_comment(repo_full_name, issue_number, claude_thoughts)

    if not success:
        raise HTTPException(status_code=500, detail="Failed to post reply")

    logger.info(f"Reply posted successfully for issue #{issue_number} in {repo_full_name}")
    return JSONResponse({"message": "Reply posted successfully"}, status_code=200)


@app.post("/webhook")
async def github_webhook(request: Request):
    try:
        secret = os.getenv("GITHUB_WEBHOOK_SECRET")
        if not secret:
            raise HTTPException(status_code=500, detail="Webhook secret not configured")

        signature = request.headers.get("X-Hub-Signature-256")
        if not signature:
            raise HTTPException(status_code=400, detail="Missing signature header")

        payload_body = await request.body()
        expected_signature = hmac.new(
            secret.encode("utf-8"), payload_body, hashlib.sha256
        ).hexdigest()
        if not hmac.compare_digest(f"sha256={expected_signature}", signature):
            raise HTTPException(status_code=401, detail="Invalid signature")

        payload = json.loads(payload_body)
        event_type = request.headers.get("X-GitHub-Event") + "." + payload.get("action")

        repository = payload.get("repository", {})
        repo_full_name = repository.get("full_name")
        ssh_url = repository.get("ssh_url")

        workdir = Path.home() / "workdir"
        workdir.mkdir(exist_ok=True)
        repo_path = workdir / repo_full_name.split("/")[-1]

        if not repo_path.exists():
            try:
                subprocess.run(
                    ["git", "clone", ssh_url, "--depth", "1"],
                    cwd=workdir,
                    check=True,
                    capture_output=True,
                    text=True,
                )
                logger.info(f"Cloned repository: {repo_full_name}")
            except subprocess.CalledProcessError as e:
                logger.error(f"Failed to clone repository {repo_full_name}: {e.stderr}")
                raise HTTPException(status_code=500, detail="Failed to clone repository")
        else:
            logger.info(f"Repository already exists: {repo_path}")
            subprocess.run(
                ["git", "checkout", "main"],
                cwd=repo_path,
                check=True,
                capture_output=True,
                text=True,
            )

        if event_type == "issues.labeled":
            return await handle_issues_labeled(repo_path, payload)
        elif event_type == "issue_comment.created":
            return await handle_issue_comment_created(repo_path, payload)
        else:
            logger.info(f"Event ignored: {event_type}")
            return JSONResponse({"message": "Event ignored"}, status_code=200)

    except Exception as e:
        logger.error(f"Webhook error: {e}")
        raise HTTPException(status_code=500, detail=e)


@app.get("/")
async def health_check():
    return {"status": "GitHub Issue Webhook is running"}


if __name__ == "__main__":
    port = int(os.getenv("PORT", "8000"))
    uvicorn.run(app, host="0.0.0.0", port=port)
